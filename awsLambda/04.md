# Cold start vs Hot start 

- When we create a multiple lambda functions, AWS behind the scenes creates a separate execution environment for you function.
- By separate execution environment , You can imagine that you create a virual machine and your code goes inside that (this actually didnot happen , virtual machine is not created)
- Now imagine that the first event came , a new execution environment was created and entire lambda function would run inside that. Then the second event came and it would run inside that . Then the third event come and third execution environment happended.But it does not happen like this.
- Meaning, the first event was triggered , as soon as the first event happened your your lambda ran and after just a few seconds the second event came , then your lambda function will run in the same execution environment as your previous one , so when it runs inside that , a lot of things have already been initialized there , so it wouldn't take much time to execute.
- doing practically by making a new lambda function and test it , it would take approx 90ms but then after we teset again , it will take 2 ms . because when your lambda function ran for the first time ,then the execution environment itself didnot exist , so earlier that an execution environment was created and your lambda runs inside it. 
- When you ran this lambda  the second time with same or different event , the execution environment had already prepared. Lambda see that this function was executed just a little while ago the last time ,  so same execution environment will be used .
- This first thing when execution environment was first created , is called cold start . The second is hot start or warm start , when you already have an execution environment. 

```javascript
let cold_start_time = null;
export const handler = async (event) => {
  // TODO implement
  
  let start_type;
  if(cold_start_time === null){
    await new Promise(resolve => setTimeout(resolve, 3000))
    cold_start_time = Date.now();
    start_type = 'cold start'
  }
  else {
    start_type = 'hot start'
  }

  const current_time = Date.now();

  
  const response = {
    "current_Time" : current_time,
    "cold_start_time" : cold_start_time,
    "start_type" : start_type
  };
  return {
    statusCode: 200,
    body: JSON.stringify(response),
  };
};
```

- if we test this first , then get output 
```
{
  "statusCode": 200,
  "body": "{
        "current_Time\":1754308930545,
        "cold_start_time\":1754308930545,
        "start_type\":\"cold start\"
    }"
}
```
- if we test again , then get output 
```
{
  "statusCode": 200,
  "body": "{
        "current_Time\":1754309074742,
        "cold_start_time\":1754308930545,
        "start_type\":\"hot start\"
    }"
}
```
- you see cold_start_time is same which means if uses same execution environment 


# use case of this 
- database connectivity or anyother connectivity work 
- you don't have to connect to database again and again , as database connection can take some time and as lambda function charges only for time your function takes 

