# context object 

- In context object , the infrastructure of your lambda function, small information realted to it is stored.
- like its name, memory limit , function version , arm , aws resource name of function and many things . 


---

# Synchronous and Asynchronous invocations 

- create a lambda function and set its timeout 30 seconds 
- Now write a code 

```javascript
export const handler = async(event,context)=>{
    await new Promise(resolve => setTimeOut(resolve,5000))
    console.log('event',event)
    return {
        'statusCode' : 200,
        'body' : JSON.stringify('Hello from lambda!')
    }
}

// this lambda function will be delayed for 5 seconds before giving response 
```
- if we test this code without cli , then got output as 
```
{
  "statusCode": 200,
  "body": "\"Hello from Lambda!\""
}
```

- Now in this we have to wait for the function till we do not get the response. 
- This waiting time is called synchronous
- Now to test synchronous behaviour , use cloudshell cli  , by writing command **aws lambda invoke --function-name name_of_your_Function output.txt**   . this output.txt is name of file where we store the function output 
- this will give result after 5 seconds with status code 200
```
{
    "StatusCode": 200,
    "ExecutedVersion": "$LATEST"
}

```
- and in output.txt file we get output 
```
{"statusCode":200,"body":"\"Hello from Lambda!\""}~ $ 
```
- by writing this on cli , if we check cloudwatch logs we get event value as empty object as we did not pass event object by cli 

- NOw to test asynchronous behaviour , use command **aws lambda invoke --function-name name_of_your_Function --invocation-type Event output.txt**
- this command will return response immediately with status code 202 and in output.txt , there will not be any output 

```
{
    "StatusCode": 202
}
```

- so in synchronous invocations:- client wait for lambda function to execute and then get the output 
- in asynchronous , user pass the event value will be stored in event queue and different process will run which pass this event value to lambda function and lambda function will process it side by side
- in cloudwatch logs , event object will still be empty 
- for eg, s3 trigger the lambda function asynchronously 


---

- Now if there is any error in the code , then in case of synchronous we get the error at that time but in case of asynchronous, we don't get the error at that time. we get status code 202 because our  code will not go to event queue and it will run at the background . We get the error in the cloudwatch logs later after 1-2 minutes. Also we get error 3 times because in **configuration > asynchronous invocation** , we have retry attempts 2 which means if asynchronous code fails , it try again for 2 times after 1 minutes delay 
- also in case of asynchronous call of lambda function , you function must be idempodent. 
- There is also something called **maximum age of event** :- the longest time Lambda retains an event in its internal queue before discarding itâ€”is 6 hours (21,600 seconds)


---
- Now we attempt both tries but it still fails then we can configure **dead latter queue** to notify user about the failure of lambda function

- in this **dead latter queue** , we can send that event object on **SNS** Simple Notification service . Secondly we can put it in a queue **SQS**. 
- We choose **SNS**  and only event object will be sent in the notifications. Here you can make the topic name global . 
- Now first we don't have permission to publish any notification on SNS or any message. so first we need to give permission. 
- For this go to **configuration > permissions** and check the role assigned to lambda function. We can atach policy to this role . So go to add permissions > attach policies and search for SNS 

- Now after this make a asynchronous call from cli (the code should contain some error ) , also pass payload to it . Now wait for 1 minute as first retry will be after 1 minute 