# Integration Response 

- create a new resource response and create a method get on lambda function , enable lambda proxy integration, choose lambda function test lambda function . create the method 

- your lambda function 
```javscript
export const handler = (event,context) =>{
    console.log(event)
    return {
        'statusCode' : 200,
        'body' : JSON.stringify({'event' : 'hlo world from lamdba '}),
        'headers" : {
            'Content-type' : 'application/json',
            'custom-header' : 'customHeaderValue'
        }
    }
}
```

- now test api gateway in postman  , we get response what ever we pass in body in lambda function and headers in headers tab and status code in api status code 

```
{"event":"hlo world from lamdba "}

```

```
{
  "Content-Type": "application/json",
  "X-Amzn-Trace-Id": "Root=1-68a35c99-0dacde8af0a9c91d01748755;Parent=132f32fe308b4cb2;Sampled=0;Lineage=1:8bcc934e:0",
  "custom-header": "custom-header-value"
}

```

- if in proxy integratin and working with lambda then we must have to return all these things as it statusCode, body , headers , if we don't pass these api gateway will throw internal server error . means in case of proxy integratin with lamda response format should be proper and fixed

- but if we disable proxy integraion , what ever we send as response from lamdba like body1 field , headers1 field , all will send as response . no error from api gateway in this case 

- now if we want to change this custom-header , edit the method response and change header name as myCustomHeader. save it 
- to give value to this custom header we need to edit integration response. but first we need to disable proxy integration
- now after disable proxy integraion, edit the integration resonse and add value of header mappings as 

```
mycustomheader : integration.response.body.headers.custom-header
```

- now we test it and see our response headers as 
```
Response headers
{
  "Content-Type": "application/json",
  "X-Amzn-Trace-Id": "Root=1-68a35ebb-aa87e5dcf031e410492da7e4;Parent=315c8075bf296408;Sampled=0;Lineage=1:8bcc934e:0",
  "myCustomHeader": "custom-header-value"
}
```

```
Response body
{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}
```

- now if we want to  modify response means we want to modify our response body

- go to integration response and edit it , in mapping template body , just write 
```
{
  'name' : 'ansh'
}
```
- now test it , we see we get only this name is response body , we don't get that we are recieving before from lambda 

```
Response body
{
    'name' : 'ansh gutpa'
}
```

- now try to print lambda output in template body 
```
{
  'name' : 'ansh',
  'lambda_output' : '$input.body'           // this body is not just body in response , this body is complete  response we are getting from lambda
}
```
```
{
  Response body

    'name' : 'ansh gutpa',
    'lambda_output' : '{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}'
}
```

- now see the format of lambda_output in response body , it is in json string format not object. to extract body from this string we use util.parse

```
{
    'name' : 'ansh gutpa',
    'lambda_output' : '$input.body',
    'lambda_output_2' : '$util.parseJson($input.body)'
}
```
```
{
    'name' : 'ansh gutpa',
    'lambda_output' : '{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}',
    'lambda_output_2' : '{statusCode=200, body={"event":"hlo world from lamdba "}, headers={Content-Type=application/json, custom-header=custom-header-value}}'
}
```

```
{
    'name' : 'ansh gutpa',
    'lambda_output' : '$input.body',
    'lambda_output_2' : '$util.parseJson($input.body)',
    'lambda_output_body' : '$util.parseJson($input.body).body'
}
```

```
Response body
{
    'name' : 'ansh gutpa',
    'lambda_output' : '{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}',
    'lambda_output_2' : '{statusCode=200, body={"event":"hlo world from lamdba "}, headers={Content-Type=application/json, custom-header=custom-header-value}}',
    'lambda_output_body' : '{"event":"hlo world from lamdba "}'
}
```

- now see we get the required body but it is still json string, so need to parse again 
```
{
    'name' : 'ansh gutpa',
    'lambda_output' : '$input.body',
    'lambda_output_2' : '$util.parseJson($input.body)',
    'lambda_output_body' : '$util.parseJson($input.body).body',
    'lambda_output_body_event' : "$util.parseJson($util.parseJson($input.body).body).event"
}
```

```
{
    'name' : 'ansh gutpa',
    'lambda_output' : '{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}',
    'lambda_output_2' : '{statusCode=200, body={"event":"hlo world from lamdba "}, headers={Content-Type=application/json, custom-header=custom-header-value}}',
    'lambda_output_body' : '{"event":"hlo world from lamdba "}',
    'lambda_output_body_event' : "hlo world from lamdba "
}
```

- see before , lambda_output is our original response from lambda but api gatway have modified response to lambda_output_body_event just 

```
doubts regarding invalid json response  lambda_output_2 even using util.parseJson


## üîç What's Happening Behind the Scenes

### 1. **Your Lambda Response (as a string)**

When your Lambda returns this:

```json
'{"statusCode":200,"body":"{\"event\":\"hlo world from lamdba \"}","headers":{"Content-Type":"application/json","custom-header":"custom-header-value"}}'
```

This is a **valid JSON string**. The `body` field is a **stringified JSON object**, which is correct for API Gateway integration.

---

### 2. **Using `$input.body` in VTL**

```vtl
'lambda_output' : '$input.body'
```

This gives you the raw string from the Lambda response. So the output is:

```json
"lambda_output": "{\"statusCode\":200,\"body\":\"{\\\"event\\\":\\\"hlo world from lamdba \\\"}\",\"headers\":{\"Content-Type\":\"application/json\",\"custom-header\":\"custom-header-value\"}}"
```

‚úÖ This is a valid JSON string.

---

### 3. **Using `$util.parseJson($input.body)`**

```vtl
'lambda_output_2' : '$util.parseJson($input.body)'
```

This parses the string into a JSON object. So now you get:

```json
{
  statusCode=200,
  body={"event":"hlo world from lamdba "},
  headers={Content-Type=application/json, custom-header=custom-header-value}
}
```

‚ùå This **looks like a Java-style object**, not JSON. But **why?**

---

## ‚ö†Ô∏è Why It Looks Like Java Instead of JSON

This is **not the actual output of `$util.parseJson(...)`** ‚Äî it's likely how the object is being **rendered as a string** in your logging or debugging output.

In VTL, when you do something like:

```vtl
"$util.parseJson($input.body)"
```

without accessing specific fields, it prints the object using its **default string representation**, which may resemble Java-style syntax:

```plaintext
{statusCode=200, body={event=hlo world from lamdba }, headers={Content-Type=application/json, custom-header=custom-header-value}}
```

This is **not invalid parsing**, it's just **not JSON-formatted output** ‚Äî it's a debug-style rendering of the object.

---

## ‚úÖ How to Confirm It's Parsed Correctly

Try accessing specific fields:

```vtl
"statusCode": "$util.parseJson($input.body).statusCode",
"event": "$util.parseJson($util.parseJson($input.body).body).event"
```

If these work and return expected values, then parsing is working correctly ‚Äî you're just seeing a non-JSON string representation when printing the whole object.

---

## ‚úÖ What You Should Do

If you want to return a valid JSON object in your response mapping template, do this:

```vtl
#set($parsed = $util.parseJson($input.body))
#set($bodyParsed = $util.parseJson($parsed.body))

{
  "statusCode": "$parsed.statusCode",
  "event": "$bodyParsed.event",
  "headers": {
    "Content-Type": "$parsed.headers.Content-Type",
    "custom-header": "$parsed.headers.custom-header"
  }
}
```

This will give you a clean, valid JSON response.


```