# Modify Request Body before reach Backend using integration request

- Now in previous lecture, we pass page and size in query parameters and also verify the request in method request that these two must be present . 
- now if we want that we take as size from the user but passes to lambda as name count means we want to modify the request . 
- so first create a post method for http request and take endpoint url as any website like webhook.site ,in this website take any url . create method 

- now again first validate method request same for post as we did it for get . 
- now go to integration request and edit url query string parameters that size parameter, when it goes to server, get changed and converted to count . For this enter name count and mapped from method.request.querystring.size
- when we test , we see count variable was added in query parameters along with page and size 

- similarly , we can modify headers 


```
before

Query strings
size	4
page	1

headers
content-type	application/json


```

```
after

Query strings
size	4
page	1
count	4


headers
content-type	application/json
abc	application/json
```

```
Raw Content
{
  "id": 1,
  "name": "ansh gupta",
  "age": 2
}
```


--- 

- now if we also want to modify incoming body ? means the raw content we are getting the same what we are passing 

- for this , first we have to disable option for proxy integration , otherwise, we don't get option for modifying body 

- proxy means forward the request body as it as it came 


- now edit the intergraion request and disable the proxy integration and in mapping template write this 
```
{
  "name" : "ansh gupta",
  "queryparams" : "$input.params()"
}
```

- now test it and we get 
```
Query strings
count	4
```
- see we get only count now in query strings 

```
headers
content-type	application/json
abc	application/json
```
- we get both the headers 

```
raw content
{
  "name": "ansh gupta",
  "queryparams": "{path={}, querystring={size=4, page=2}, header={content-type=application/json}}"
}
```

- see in the raw content , we know got this instead of what we pass in request body 

- now if we write this in mapping template , 
```
{
  "name" : "ansh gupta",
  "queryparams" : {
    "page" : "$input.params().querystring.page",
    "size" : "$input.params('size')"
  },
  "headers" : {
    "content-type" : "$input.params().header"
  }
}

```

- then got output this 
```
{
  "name" : "ansh gupta",
  "queryparams" : {
    "page" : "4",
    "size" : "4"
  },
  "headers" : {
    "content-type" : "{content-type=application/json}"
  }
}
```

- similarly if we want to get body 
```
{
  "name" : "ansh gupta",
  "queryparams" : {
    "page" : "$input.params().querystring.page",
    "size" : "$input.params('size')"
  },
  "headers" : {
    "content-type" : "$input.params().header"
  },
  "data" : "$input.json('$')"
}
```
- now get the body output also 
```
{
  "name" : "ansh gupta",
  "queryparams" : {
    "page" : "2",
    "size" : "4"
  },
  "headers" : {
    "content-type" : "{content-type=application/json}"
  },
  "data" : "{"id":1,"name":"ansh gupta","age":2}"
}
```




---
# summary
- modifying requests before they reach the backend (like a Lambda function or HTTP endpoint). 

---


- using **Integration Request Mapping Templates** in **non-proxy integration** mode to:

1. **Validate incoming requests** (e.g., `page` and `size` must be present).
2. **Modify query parameters** (e.g., rename `size` to `count`).
3. **Add or change headers**.
4. **Transform the request body** before sending it to the backend.

---

## ðŸ” Proxy vs Non-Proxy Integration

| Feature | Proxy Integration | Non-Proxy Integration |
|--------|-------------------|------------------------|
| Request passed as-is | âœ… Yes | âŒ No |
| Can modify request body | âŒ No | âœ… Yes |
| Can use mapping templates | âŒ Limited | âœ… Full control |
| Easier setup | âœ… Yes | âŒ More manual |

- **Proxy Integration**: API Gateway forwards the request exactly as it came.
- **Non-Proxy Integration**: You can intercept and **transform** the request using **Velocity Template Language (VTL)**.

---
 
### 1. **Validate Method Request**
You ensured `page` and `size` are required query parameters. This is done in **Method Request** settings.

---

### 2. **Modify Query Parameters**
In **Integration Request**, you added a new query parameter `count` and mapped it from `size`:

```plaintext
count â†’ method.request.querystring.size
```

âœ… Now the backend receives:
```plaintext
Query strings: page=1, size=4, count=4
```

---

### 3. **Modify Headers**
You added a custom header `abc` and mapped it from `content-type`:

```plaintext
abc â†’ method.request.header.content-type
```

âœ… Now the backend receives:
```plaintext
Headers: content-type=application/json, abc=application/json
```

---

### 4. **Modify Request Body**
You disabled **Lambda Proxy Integration** to allow body transformation.

Then you wrote a **mapping template** like:

```json
{
  "name": "ansh gupta",
  "queryparams": "$input.params()"
}
```

âœ… Backend receives:
```json
{
  "name": "ansh gupta",
  "queryparams": "{path={}, querystring={size=4, page=2}, header={content-type=application/json}}"
}
```

You later refined it to extract specific values:

```json
{
  "name": "ansh gupta",
  "queryparams": {
    "page": "$input.params().querystring.page",
    "size": "$input.params('size')"
  },
  "headers": {
    "content-type": "$input.params().header"
  },
  "data": "$input.json('$')"
}
```

âœ… Final output:
```json
{
  "name": "ansh gupta",
  "queryparams": {
    "page": "2",
    "size": "4"
  },
  "headers": {
    "content-type": "{content-type=application/json}"
  },
  "data": "{\"id\":1,\"name\":\"ansh gupta\",\"age\":2}"
}
```

---

## ðŸŽ¯ Use Cases & Benefits

### âœ… **Why Do This?**

1. **Backend Compatibility**: Your backend expects `count` instead of `size`, or a specific body format.
2. **Security**: Strip or sanitize sensitive data before forwarding.
3. **Standardization**: Normalize headers or query parameters across different clients.
4. **Logging & Debugging**: Add metadata or trace info to requests.
5. **Legacy Support**: Adapt modern API requests to older backend formats.

---

## ðŸ‘¨â€ðŸ’» What Does the Backend Developer See?

Instead of raw client input, the backend receives a **clean, transformed payload** like:

```json
{
  "name": "ansh gupta",
  "queryparams": {
    "page": "2",
    "size": "4"
  },
  "headers": {
    "content-type": "{content-type=application/json}"
  },
  "data": "{\"id\":1,\"name\":\"ansh gupta\",\"age\":2}"
}
```

This makes it easier for the backend to:
- Parse the request.
- Avoid errors due to unexpected formats.
- Focus on business logic instead of input validation.

---


## now we have done this using this webhook.site website , now done this using lambda 


- now edit the integration request , disable lambda proxy integration , rest is as same as we done before , but choose a lambda function that returns a event just 

- we know when we are using proxy , event gets so many things , now see without proxy what will go to event now 

```
event object when using proxy 

{"event":{"resource":"/student","path":"/student","httpMethod":"POST","headers":{"content-type":"application/json"},"multiValueHeaders":{"content-type":["application/json"]},"queryStringParameters":{"size":"4","page":"3"},"multiValueQueryStringParameters":{"size":["4"],"page":["3"]},"pathParameters":null,"stageVariables":null,"requestContext":{"resourceId":"te30oq","resourcePath":"/student","httpMethod":"POST","extendedRequestId":"PgAhmFOaIAMFg_Q=","requestTime":"18/Aug/2025:11:54:24 +0000","path":"/student","accountId":"account-id","protocol":"HTTP/1.1","stage":"test-invoke-stage","domainPrefix":"testPrefix","requestTimeEpoch":1755518064277,"requestId":"9881282e-a203-4774-b64a-8aaec100a688","identity":{"cognitoIdentityPoolId":null,"cognitoIdentityId":null,"apiKey":"test-invoke-api-key","principalOrgId":null,"cognitoAuthenticationType":null,"userArn":"arn:aws:iam::864965618223:root","apiKeyId":"test-invoke-api-key-id","userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36","accountId":"864965618223","caller":"864965618223","sourceIp":"test-invoke-source-ip","accessKey":"ASIA4SY7X5IX6O34IBLM","cognitoAuthenticationProvider":null,"user":"864965618223"},"domainName":"testPrefix.testDomainName","apiId":"8lfiwn0kuf"},"body":"{\n  \"id\" : 1,\n  \"name\" : \"ansh gupta\",\n  \"age\" : 2\n}","isBase64Encoded":false}}

```

- now when we test it by passing everthing query params , headers , request body , we get internal server error related to request signature. this is due to multiple content-type headers , as content-type header is by default send and we are also sending it , so remove content-type header 



## ðŸ” The Error Again

> **"The request signature we calculated does not match the signature you provided."**

This means:  
**AWS is expecting a request with a specific signature**, but the actual request it receives is **different** â€” so it **rejects** it.

---

## ðŸ§  How AWS Signature Works (Simplified)

When a client (like Postman, SDK, or CLI) sends a request to AWS, it:
1. **Creates a hash** of the request â€” including:
   - HTTP method
   - URL
   - Query parameters
   - Headers (especially `Content-Type`, `Host`, etc.)
   - Body
2. **Signs** that hash using the AWS Secret Access Key.
3. **Sends the request** with the signature in the `Authorization` header.

Then AWS:
- Recalculates the hash using the request it receives.
- Compares it with the signature sent.
- If they **donâ€™t match**, it throws the error.

---

## âš ï¸ What Went Wrong in Your Case

### âœ… You Required `Content-Type` in Method Request
- So the client sends:  
  `Content-Type: application/json`

### âŒ You Mapped `Content-Type` in Integration Request
- You added this in **Integration Request**:
  ```plaintext
  Header Name: content-type  
  Mapped from: method.request.header.content-type
  ```

This causes API Gateway to **manually set or override** the `Content-Type` header when forwarding the request to the backend.

### ðŸ”¥ Problem

- The client signed the request with `Content-Type: application/json`
- But API Gateway **reconstructs** the request and **re-adds** or **modifies** the `Content-Type` header
- So the backend receives a request that is **not byte-for-byte identical** to the one that was signed

âž¡ï¸ **Signature mismatch!**

---

## âœ… Why Removing the Header Mapping Fixes It

When you remove the `content-type` mapping:
- API Gateway **does not touch** the `Content-Type` header
- It forwards the request **exactly as the client sent it**
- So the signature matches âœ…

---

## ðŸ§ª Analogy

Imagine signing a document that says:

> "Hello, my name is Ansh."

Then someone changes it to:

> "Hello, my name is Ansh Gupta."

Even though itâ€™s a small change, your signature no longer matches the document â€” and itâ€™s rejected.

---

## ðŸ§° Best Practices

- **Avoid mapping headers like `Content-Type`, `Authorization`, `Host`** in Integration Request unless absolutely necessary.
- If you're using **signed requests**, keep the request untouched.
- Use **proxy integration** if you want to forward the request exactly as it came.

---


- now next error comes is 
```
{"message": "Could not parse request body into json: Could not parse payload into json: Unexpected character (\'i\' (code 105)): was expecting comma to separate Object entries\n at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 10, column: 15]"}
```

- this is becasue in the integation request, the mapping template we are sending is not valid json , it is vtl language , so for valid json use **$util.escapeJavaScript($input.json('$'))** with the body 

```
{
  "name" : "ansh gupta",
  "queryparams" : {
    "page" : "$input.params().querystring.page",
    "size" : "$input.params('size')"
  },
  "headers" : "$input.params().header",
  "data" : "$util.escapeJavaScript($input.json('$'))"
}
```
- now if we test it , we get response from lambda function which is sending just event as 


```
{"statusCode":200,"body":"{\"event\":{\"name\":\"ansh gupta\",\"queryparams\":{\"page\":\"5\",\"size\":\"4\"},\"headers\":\"{content-type=application/json}\",\"data\":\"{\\\"id\\\":4,\\\"name\\\":\\\"ansh gupta\\\",\\\"age\\\":1}\"}}"}
```

- we get same event object as what we write in mapping template 

- now what if we don't write anything in mapping template then our event object will be empty 

```
{"statusCode":200,"body":"{\"event\":{}}"}
```
- see our event object is empty if we don't write anything in mapping template even if we are passing query parameters and headers 

- but if we pass our request body then it will shown in the event 
```
{"statusCode":200,"body":"{\"event\":{\"id\":4,\"name\":\"ansh \",\"age\":5}}"}
```

