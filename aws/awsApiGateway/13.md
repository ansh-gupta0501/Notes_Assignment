# Authenticate API Gateway Using IAM Roles

- create a new resource demo-auth on / path and create a method get and lambda integraion , enable lambda proxy integration. choose a simple lambda function which just returns hlo message

```
export const handler = async (event,context) =>{
  console.log(event)
  return {
      'statusCode' : 200,
      'body' : JSON.stringify({'event' : 'hlo world from lamdba '}),
      
    }
}
```
- now first test it we get proper response 
```
{"event":"hlo world from lamdba "}
```
- Now to put authetication on this url , there are multiple ways
- first , in method request , edit it and set AWS iam in authorization option . this means  only iam users of the aws can hit this endpoint 
- if we hit this we get 
```
{
  "message": "Missing Authentication Token"
}
```
- and status code 403 which means you have not permission to access this 

- now to access this create a iam user by going to iam > users and create user , 
- now to create access keys for these, so go to security credentials in the user and create access key 
- choose command line interface and create access key . 
- now we need to put this access key and secret access key in postman , in authorzation tab choose aws signature and put your keys there . if want also give regions and other configuration like service name and session token(not mandatory)
- postman behind the scenes create the signature based on these keys and put it in the header and send to server 
- now after all this if we hit we get error 
```
{"Message":"User: arn:aws:iam::864965618223:user/ansh_iam is not authorized to perform: execute-api:Invoke on resource: arn:aws:execute-api:us-east-1:********8223:8lfiwn0kuf/dev/GET/demo-auth"}
```
- this error means this user has not any permission to hit any api 
- so now go to iam again and in permission add permission > attach policy >amazon api gatway full access .(you can also give paritcular api permission to this user )

- not hit again , now we get the response 
```
{"event":"hlo world from lamdba "}
```


- Now in this we sercured our api on the basis of user 

- but we can also do this with the help of role , that is, you attach a role to an ec2 and that ec2 instance is able to hit your api 

- this method of authentication is helpful if aws another service wanted to talk to your api gateway 
- example , suppose your application is deployed on ec2, so if your api gatway talk with this ec2 then you can use your this method of iam 

- drawback of this method is that we can't put any limitation on this method like rate limiting ,throttling on this , as these are external service 


---

- so for this we use another method which is using API KEYS  

- so first go to api method request setting ,edit it and make authorisation node and enable api key required option 
- now when we hit it we get error 
```
{"message":"Forbidden"}

```

- now to solve this , we need to create a api key , for this go to api key option , create it , name it and auto generate it 
- now put this api key into headers with name as x-api-key and value your api key 
- but we get same error 
```
{"message":"Forbidden"}

```
- because we need to tell for which api gateway this key is for 
- for this we need to set usage plan for this , go to usage plan of this api key, create usage plan 
- name it and disable both throttling and quata 
- now  need to add this usage plan to this api key 

- but still we can't hit the request 

- now go to usage plan we have made , there is associated stages option , add api stage, select the api the first rest api and stage dev
- now hit the request , and now we can access the url , also remember the add the header x-api-key

---

# Uses Custom Authorizer in your api gateway 

- Custome Authorizer is custom logic for authentication 
- you take a token from user ,validate it 
- like you take a username and password from user , and when user sign in then your authencation api give him a token . Now user again hit another api , the user put that token in header . we have to validate only is it valid token or not 

- create a new resource custom-auth on / path and create a get method for lambda function testlambdafunction which just returns a string hlo from lambda 

- now we create a lambda function for authentication which is used for just allowing or denying a request . Now this allowing or denying a request is done by policies in aws so this lambda function just return policies 

- complete flow is like that 

```
client hit request  ---> api gateway -> lambda auth function 

if lamdba auth function allowed the request then request goes further to other lamdba functions else not 
```

- so make a lambda function and return a allow policy with principle

```
export const handler = async (event) => {
  // return a allow policy with principle
  return {
    "principalId": "user",
    "policyDocument": {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Action": "execute-api:Invoke",
          "Effect": "Allow",
          "Resource": "arn:aws:execute-api:us-east-1:864965618223:8lfiwn0kuf/*/GET/custom-auth"
        }
      ]
    },
    
  };
  
};

in the resource option we have put arn of our api on which we want authentication , 
```

- when this auth lambda function hit , it returns the same policy everytime and allow the request 

- now go to the api firstRestApi and go to authorizers tab , create it and name the authorizers custom-lambda-authorizers 

- select type lambda and choose our authLambda function 
- select token in lambda event payload 
- in the token source , enter the header name means token will go to this header **LOheader**
- in the token validation , we can put like our header should start from bearer or any name , this type of validation 

- this is useful that if user gives dummy token , no need to hit that authlambda function 

- now edit the method request , enable the authorization , and select this autheizer 

- now if we hit the request via a postman we get errro 
```
{"message":"Missing Authentication Token"}
```

- so need to pass header value , also as now we are not checking any header value , our auth lambda is just allowing every request , so if pass any value it will work 
```
LOheader da5dfafd        // random value but key must be LOheader we set before 
```
now hit the request we get output 
```
{"event":"hlo world from lamdba "}
```

- if in lambda function we deny the request , then our error is 
```
{
  "Message": "User is not authorized to access this resource with an explicit deny"
}
```

- if we check event in logs event value is 
```
event {
  type: 'TOKEN',
  methodArn: 'arn:aws:execute-api:us-east-1:864965618223:8lfiwn0kuf/dev/GET/custom-auth',
  authorizationToken: 'adsfadfas'
}
```

- so as in our auth lambda policy we are hardcoded resource value which should not ,as if there are multiple api we need for authentication we need to add manually the name of them . also need to verify token 

```
export const handler = async (event) => {
  console.log('event',event);
  const token = event.authorizationToken;

  let action = 'Deny'
  if(token === 'secretkey'){
    action = 'Allow'
  }

  // return a allow policy with principle
  return {
    "principalId": "user",
    "policyDocument": {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Action": "execute-api:Invoke",
          "Effect": action,
          "Resource": event.methodArn
        }
      ]
    },
    
  };
  
};

```

- now if we hit request by passing header LOheader witht value secretkey then we get our response helo from lambda else got error 

- now this token can be jwt token or any token 
- also we know we can put user information like id , name inside token , so for this 

- for this first in testlambdafunction , just return event instead of simple string message 
- and in auth lambda function , make a new function which decodes the token as we know in jwt for getting user info we need to decode the token 

- now see the event object before doing these passing user details step 
```
{
  "event": {
    "resource": "/custom-auth",
    "path": "/custom-auth",
    "httpMethod": "GET",
    "headers": {
      "Accept": "*/*",
      "accept-encoding": "gzip, deflate, br",
      "Host": "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com",
      "LOheader": "secretkey",
      "User-Agent": "Thunder Client (https://www.thunderclient.com)",
      "X-Amzn-Trace-Id": "Root=1-68a4533d-2aee924a4e83c15a44cf7cc5",
      "X-Forwarded-For": "14.98.168.70",
      "X-Forwarded-Port": "443",
      "X-Forwarded-Proto": "https"
    },
    "multiValueHeaders": {
      "Accept": [
        "*/*"
      ],
      "accept-encoding": [
        "gzip, deflate, br"
      ],
      "Host": [
        "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com"
      ],
      "LOheader": [
        "secretkey"
      ],
      "User-Agent": [
        "Thunder Client (https://www.thunderclient.com)"
      ],
      "X-Amzn-Trace-Id": [
        "Root=1-68a4533d-2aee924a4e83c15a44cf7cc5"
      ],
      "X-Forwarded-For": [
        "14.98.168.70"
      ],
      "X-Forwarded-Port": [
        "443"
      ],
      "X-Forwarded-Proto": [
        "https"
      ]
    },
    "queryStringParameters": null,
    "multiValueQueryStringParameters": null,
    "pathParameters": null,
    "stageVariables": null,
    "requestContext": {
      "resourceId": "vwghns",
      "authorizer": {
        "principalId": "user",
        "integrationLatency": 326
      },
      "resourcePath": "/custom-auth",
      "httpMethod": "GET",
      "extendedRequestId": "PjHxpGdTIAMEsdA=",
      "requestTime": "19/Aug/2025:10:34:37 +0000",
      "path": "/dev/custom-auth",
      "accountId": "864965618223",
      "protocol": "HTTP/1.1",
      "stage": "dev",
      "domainPrefix": "8lfiwn0kuf",
      "requestTimeEpoch": 1755599677323,
      "requestId": "a7e2787d-e926-4d95-a6f5-447ab99d5599",
      "identity": {
        "cognitoIdentityPoolId": null,
        "accountId": null,
        "cognitoIdentityId": null,
        "caller": null,
        "sourceIp": "14.98.168.70",
        "principalOrgId": null,
        "accessKey": null,
        "cognitoAuthenticationType": null,
        "cognitoAuthenticationProvider": null,
        "userArn": null,
        "userAgent": "Thunder Client (https://www.thunderclient.com)",
        "user": null
      },
      "domainName": "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com",
      "deploymentId": "3dy23i",
      "apiId": "8lfiwn0kuf"
    },
    "body": null,
    "isBase64Encoded": false
  }
}
```

- after passing user details by updating your auth lambda code as 
```
 const decodeToken = async(token)=>{
  // token decoded 
  //return payload 
  
  return {
    "username" : "ansh",
    "isAdmin" : true,
    "user_id" : 500
  }
 } 

export const handler = async (event) => {
  console.log('event',event);
  const token = event.authorizationToken;

  let action = 'Deny'
  if(token === 'secretkey'){
    action = 'Allow'
  }

  const userDetail = await decodeToken(token)

  // return a allow policy with principle
  return {
    "principalId": "user",
    "policyDocument": {
      "Version": "2012-10-17",
      "Statement": [
        {
          "Action": "execute-api:Invoke",
          "Effect": action,
          "Resource": event.methodArn
        }
      ]
    },
    "context": userDetail
    
  };
  
};

```

- now the event value is 
```
{
  "event": {
    "resource": "/custom-auth",
    "path": "/custom-auth",
    "httpMethod": "GET",
    "headers": {
      "Accept": "*/*",
      "accept-encoding": "gzip, deflate, br",
      "Host": "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com",
      "LOheader": "secretkey",
      "User-Agent": "Thunder Client (https://www.thunderclient.com)",
      "X-Amzn-Trace-Id": "Root=1-68a456d0-304d950f2dc6b4775989d538",
      "X-Forwarded-For": "14.98.168.70",
      "X-Forwarded-Port": "443",
      "X-Forwarded-Proto": "https"
    },
    "multiValueHeaders": {
      "Accept": [
        "*/*"
      ],
      "accept-encoding": [
        "gzip, deflate, br"
      ],
      "Host": [
        "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com"
      ],
      "LOheader": [
        "secretkey"
      ],
      "User-Agent": [
        "Thunder Client (https://www.thunderclient.com)"
      ],
      "X-Amzn-Trace-Id": [
        "Root=1-68a456d0-304d950f2dc6b4775989d538"
      ],
      "X-Forwarded-For": [
        "14.98.168.70"
      ],
      "X-Forwarded-Port": [
        "443"
      ],
      "X-Forwarded-Proto": [
        "https"
      ]
    },
    "queryStringParameters": null,
    "multiValueQueryStringParameters": null,
    "pathParameters": null,
    "stageVariables": null,
    "requestContext": {
      "resourceId": "vwghns",
      "authorizer": {
        "user_id": "500",
        "principalId": "user",
        "integrationLatency": 376,
        "isAdmin": "true",
        "username": "ansh"
      },
      "resourcePath": "/custom-auth",
      "httpMethod": "GET",
      "extendedRequestId": "PjKAtFEnoAMEmsw=",
      "requestTime": "19/Aug/2025:10:49:52 +0000",
      "path": "/dev/custom-auth",
      "accountId": "864965618223",
      "protocol": "HTTP/1.1",
      "stage": "dev",
      "domainPrefix": "8lfiwn0kuf",
      "requestTimeEpoch": 1755600592968,
      "requestId": "d43614e7-ccb5-4bb8-8bf0-6fe5d7a84018",
      "identity": {
        "cognitoIdentityPoolId": null,
        "accountId": null,
        "cognitoIdentityId": null,
        "caller": null,
        "sourceIp": "14.98.168.70",
        "principalOrgId": null,
        "accessKey": null,
        "cognitoAuthenticationType": null,
        "cognitoAuthenticationProvider": null,
        "userArn": null,
        "userAgent": "Thunder Client (https://www.thunderclient.com)",
        "user": null
      },
      "domainName": "8lfiwn0kuf.execute-api.us-east-1.amazonaws.com",
      "deploymentId": "3dy23i",
      "apiId": "8lfiwn0kuf"
    },
    "body": null,
    "isBase64Encoded": false
  }
}
```

- see we get the user data in requestContext > authorizer