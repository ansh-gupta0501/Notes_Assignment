# API Gateway with Rest API Integration with HTTP Server

- In http api , in integrations we get only 2 options lambda and http endpoint . 

- when you create rest api , first you get four options:- create new api , clone existing api , import api , example api 
- we first create new api , in which we give name , description 
- in api endpoint type , it means from which places your api can hit from . it has 3 options : regional, edge-optimized, private .
- Regional APIs are deployed in the current AWS Region. Edge-optimized APIs route requests to the nearest CloudFront Point of Presence. Private APIs are only accessible from VPCs.
- choose regional and create api  
- now create a method for this, choose http , select any method type , enable http proxy integraion , again http method , endpoint url like example.com and rest is default .
- now deploy and make a stage dev , now we get url which hit on our example.com 



## 🚪 What is AWS API Gateway (REST API)?

**API Gateway** is a service that acts as a **middleman** between your frontend (like a website or app) and your backend services (like microservices or HTTP servers). It handles:
- Routing requests
- Authentication & authorization
- Monitoring
- Caching
- Rate limiting
- Load balancing

---

## 🧭 Types of API Gateway (Recap)

When creating an API, you choose the **endpoint type**, which defines **how and where** your API is accessible:

| Type | Description | Use Case |
|------|-------------|----------|
| **Regional** | Accessible in a specific AWS region | Internal or region-specific apps |
| **Edge-Optimized** | Uses CloudFront to serve globally | Public APIs for global users |
| **Private** | Accessible only inside your VPC | Internal services, secure apps |

---

## 🛠️ Steps to Create a REST API with HTTP Integration

### ✅ Step 1: Create REST API
- Go to API Gateway → Create API → Choose **REST API**
- Choose **Create new API**
- Give it a **name** and **description**
- Choose **Endpoint Type** (e.g., Regional)

### ✅ Step 2: Create Resources and Methods
- A **resource** is a path like `/example`, `/order`, `/cart`
- A **method** is an HTTP action like GET, POST, PUT, DELETE

#### Example:
- Create resource `/example`
- Under `/example`, create method `GET`
- Integration type: **HTTP**
- Endpoint URL: `https://example.com`
- Enable **HTTP Proxy Integration** (optional)

> 🔹 **HTTP Proxy Integration** means the entire request is forwarded as-is to the backend server. You don’t need to map headers, query strings, etc.

### ✅ Step 3: Deploy the API
- Create a **stage** (e.g., `dev`, `prod`)
- Deploy the API to that stage
- AWS gives you a **URL** like:
  ```
  https://abc123.execute-api.us-east-1.amazonaws.com/dev/example
  ```

### ✅ Step 4: Test the API
- Open the URL in a browser or use tools like Postman or curl
- If everything is set up correctly, it should hit your backend server (`example.com`)

---

## 🧠 Extra Features in REST API (Compared to HTTP API)

| Feature | REST API | HTTP API |
|--------|----------|----------|
| Custom Authorizers | ✅ Yes | ❌ No |
| Request/Response Mapping | ✅ Yes | ❌ Limited |
| Usage Plans & API Keys | ✅ Yes | ❌ No |
| Caching | ✅ Yes | ✅ Yes |
| Monitoring | ✅ Yes | ✅ Yes |
| Cost | 💰 Higher | 💸 Lower |

---

## 🔍 Clarifying Your Question: Are `/order`, `/example`, `/learn` Microservices?

These **paths** are just **routes** in API Gateway. Whether they point to:
- A **microservice** (like a Node.js app running on EC2 or ECS)
- A **server** (like `example.com`)
- A **Lambda function**

...depends on what you configure in the **integration URL**.

So:
- If `/order` routes to a microservice handling orders → yes, it's a microservice.
- If `/learn` routes to a public website → it's just a server.

---

## ✅ Summary

- **REST API** in API Gateway is powerful and full-featured.
- You define **resources** (paths) and **methods** (GET, POST).
- You integrate with **HTTP servers**, **Lambda**, or other AWS services.
- You deploy to **stages** and get a public URL.
- You can add **security**, **monitoring**, **rate limiting**, and more.

---



## 🔌 What is HTTP Proxy Integration?

Imagine you’re building an API Gateway route like `/example`, and you want it to forward the request to `https://example.com`.

There are **two ways** to do this:

### 1. **Non-Proxy Integration**
- You manually define:
  - Which headers to pass
  - Which query parameters to forward
  - How to format the request and response
- You have **full control** but need to configure everything.

### 2. **HTTP Proxy Integration** ✅
- API Gateway **automatically forwards** the entire request to the backend server.
- It acts like a **transparent tunnel** — no need to configure headers, query strings, or body mappings.
- Whatever the client sends → API Gateway forwards it as-is → backend server processes it.

---

## 🧠 Simple Analogy

Imagine API Gateway is a **messenger**:

- 🧍 Without proxy: You tell the messenger exactly what to say, how to say it, and what to bring back.
- 🚴 With proxy: You just say “Go deliver this message,” and the messenger repeats it exactly as you said.

---

## ✅ Benefits of HTTP Proxy Integration

- **Quick setup** — no need to configure request/response mappings
- **Flexible** — supports all HTTP methods (GET, POST, PUT, DELETE, etc.)
- **Useful for microservices** — especially when you already have a backend that handles requests properly

---

## 🔍 Example

Let’s say you configure:
- Resource: `/example`
- Method: `ANY`
- Integration type: **HTTP Proxy**
- Endpoint: `https://example.com`

Now:
- A request to `https://your-api-id.execute-api.amazonaws.com/dev/example?item=book`
- Will be forwarded as:
  ```
  GET https://example.com?item=book
  ```

Including:
- Headers
- Query parameters
- Request body

---

## ⚠️ Things to Keep in Mind

- Your backend must be ready to handle the full request.
- You lose fine-grained control over request/response transformation.
- If you need custom logic (like modifying headers or body), use **non-proxy integration**.

---
